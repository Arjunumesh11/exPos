//INT 9
//EXEC
alias userSP R0;
alias current_pid R1;
alias process_table R2;
alias block_num R5;
alias page_num R6;

userSP=SP;
current_pid = [SYSTEM_STATUS_TABLE + 1];
// print current_pid;
process_table = PROCESS_TABLE + 16*current_pid;
//setting mod to 9 systemcall no
[process_table + 9] = 9;

[process_table + 13] = SP;
SP = [process_table + 11]*512 - 1;

alias filename R3;
filename=[[PTBR + 2*(userSP - 4)/512]*512 + (userSP-4)%512];
alias inode_itr R4;
inode_itr = 1;
while (inode_itr<MAX_FILE_NUM) do
    if([INODE_TABLE + 16*inode_itr + 1] == filename) then
        if([INODE_TABLE + 16*inode_itr]!=EXEC) then
            inode_itr = MAX_FILE_NUM;
        endif;
        break;
    endif;
    inode_itr = inode_itr + 1;
endwhile;
//could not find the file
if(inode_itr==MAX_FILE_NUM) then
    //setting return value to -1
    print "NO file";
    [[PTBR + 2*(userSP - 1)/512]*512 + (userSP-1)%512] = -1;
else    
    multipush(R1,R2,R3,R4);
    alias function_num R1;
    alias PID R2;
    PID = current_pid;
    //exit_process function
    function_num = 3; 
    call PROCESS_MANAGER;
    multipop(R1,R2,R3,R4);
    //regaining userpage
    [MEMORY_FREE_LIST + [process_table + 11]] = 1;
    //reducing mem_count
    [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2]-1;
    SP = [process_table + 11]*512 - 1;
    [process_table + 7] = inode_itr;
    [process_table + 4] = RUNNING;

    //setting page_table entry for new process
    PTBR = process_table;
    //library
    //read only
    [PTBR+0] = 63;
    [PTBR+1] = "0100";
    [PTBR+2] = 64;
    [PTBR+3] = "0100";

    //getting page for stack and heap;
    multipush(R1,R2,R3,R4);
    //get page table function
    function_num = 1; 
    call MEMORY_MANAGER;
    //Heap
    [PTBR+4] = R0;
    [PTBR+5] = "0110";
    function_num = 1; 
    call MEMORY_MANAGER;
    [PTBR+6] = R0;
    [PTBR+7] = "0110";
    
    //Stack
    function_num = 1; 
    call MEMORY_MANAGER;
    [PTBR+16] = R0;
    [PTBR+17] = "0110";
    function_num = 1; 
    call MEMORY_MANAGER;
    [PTBR+18] = R0;
    [PTBR+19] = "0110";
    
    multipop(R1,R2,R3,R4);
    //Code
   
    if ([INODE_TABLE + 16*inode_itr + 8]!=-1) then
        multipush(R1,R2,R3,R4);
        //get page table function
        // print "code";
        function_num = 1; 
        call MEMORY_MANAGER;
        [PTBR+8] = R0;
        [PTBR+9] = "0100";
        multipop(R1,R2,R3,R4);
        block_num = [INODE_TABLE + 16*inode_itr + 8];
        page_num = [PTBR +8]; 
        call mem_manager;
    endif;
    if ([INODE_TABLE + 16*inode_itr + 9]!=-1) then
        multipush(R1,R2,R3,R4);
        //get page table function
        function_num = 1; 
        call MEMORY_MANAGER;
        [PTBR+10] = R0;
        [PTBR+11] = "0100";
        multipop(R1,R2,R3,R4);
        block_num = [INODE_TABLE + 16*inode_itr + 9];
        page_num = [PTBR + 10 ]; 
        call mem_manager;
    endif;
    if ([INODE_TABLE + 16*inode_itr + 10]!=-1) then
        multipush(R1,R2,R3,R4);
        //get page table function
        function_num = 1; 
        call MEMORY_MANAGER;
        [PTBR+12] = R0;
        [PTBR+13] = "0100";
        multipop(R1,R2,R3,R4);   
        block_num = [INODE_TABLE + 16*inode_itr + 10];
        page_num = [PTBR + 12 ]; 
        call mem_manager;
    endif;
    if ([INODE_TABLE + 16*inode_itr + 11]!=-1) then
        multipush(R1,R2,R3,R4);
        //get page table function
        function_num = 1; 
        call MEMORY_MANAGER;
        [PTBR+14] = R0;
        [PTBR+15] = "0100";
        multipop(R1,R2,R3,R4);
        block_num = [INODE_TABLE + 16*inode_itr + 11];
        page_num = [PTBR + 14 ]; 
        call mem_manager;
    endif; 
        alias stack_mem R5;
        alias code_mem R6;

        stack_mem = [PTBR+16];
        code_mem = [PTBR+8];
        [stack_mem*512] = [code_mem*512+1];
        SP = 8*512;

        ireturn;
    
    
endif;
[process_table +9] = 0;
SP = [process_table + 13];
ireturn;

mem_manager:
    // print "mem";
    multipush(R1,R2,R3,R4,R5);
    R2 = current_pid; 
    R1 = 2;
    R3 = page_num;
    R4 = block_num;

    call DEVICE_MANAGER;
    multipop(R1,R2,R3,R4,R5);
return;
