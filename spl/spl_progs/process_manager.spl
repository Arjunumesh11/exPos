//process manager
//MOD 1

//R1 is function number
//R2 PID of current proccess
alias functionNum R1;
alias currentPID R2;

//for release page function
alias block_num R5;

//get pcb entry
if (functionNum == GET_PCB_ENTRY) then
    alias process_itr R3;
    process_itr = 1;
    while (process_itr<16) do
        if([PROCESS_TABLE + 16*process_itr + 4] == TERMINATED) then
            [PROCESS_TABLE + 16*process_itr + 1] = process_itr;
            [PROCESS_TABLE + 16*process_itr + 4] = ALLOCATED;
            [PROCESS_TABLE + 16*process_itr + 14] = PAGE_TABLE_BASE + 20*process_itr;
            [PROCESS_TABLE + 16*process_itr + 15] = 10 ;
            R0 = process_itr;
            print "get_pcb";
            // breakpoint;
            return;
    endif;
    process_itr = process_itr + 1;
    endwhile;
    if(process_itr == 16) then
        R0 = -1;
        return;
    endif;
    return;
endif;


//Free user area page
if (functionNum == FREE_USER_AREA_PAGE) then
    alias process_table R3;
    process_table = PROCESS_TABLE + 16*currentPID;
    //release page
    block_num = [process_table + 11];
    call release_page;
    return;
endif;

//EXIT_process
if (functionNum == 3) then
    alias process_table R3;
    process_table = PROCESS_TABLE + 16*currentPID;
    //Free page table
    multipush(R1,R2,R3);
    functionNum = FREE_PAGE_TABLE;
    call PROCESS_MANAGER;
    multipop(R1,R2,R3);    
    //Free user area page
    multipush(R1,R2,R3);
    functionNum = FREE_USER_AREA_PAGE;
    call PROCESS_MANAGER;
    multipop(R1,R2,R3);    
    [ process_table + 4 ] =TERMINATED;
    if([PROCESS_TABLE +16*currentPID + 9]!=INT_EXEC) then
        alias process_itr R4;
        process_itr = 0;
        while (process_itr < MAX_PROC_NUM) do
            if ([PROCESS_TABLE + 16*process_itr + 4 ] == WAIT_PROCESS) then
                if([PROCESS_TABLE + 16*process_itr + 5 ] == currentPID) then
                    [PROCESS_TABLE + 16*process_itr + 4 ] = READY;
                    [PROCESS_TABLE + 16*process_itr + 5 ] = -1;
                endif;
            endif;
            if ([PROCESS_TABLE + 16*process_itr +  2] == currentPID) then
                [PROCESS_TABLE + 16*process_itr +  2] = -1;
            endif;
            process_itr = process_itr + 1;
        endwhile;
    endif;
    return;
endif;
//Free page table
if (functionNum == FREE_PAGE_TABLE) then
//--------------->Need to change to loop 
    //invalidating page table
    //library
    alias page_itr R4;
    page_itr = 0;
    while (page_itr<20) do
        if ([ PTBR + page_itr ]!=-1) then
            block_num = [ PTBR + page_itr ];
            call release_page;
            [ PTBR + page_itr ] = -1;
            [ PTBR + page_itr + 1] = "0000"; 
            call release_block;           
        endif;
        page_itr = page_itr + 2;
    endwhile;
    //invalidating al disk mpa table of current process
    [DISK_MAP_TABLE + 10*currentPID ] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 1] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 2] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 3] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 4] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 5] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 6] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 7] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 8] = -1;
    [DISK_MAP_TABLE + 10*currentPID + 9] = -1;
    return;
endif;

release_page:
    multipush(R1,R2,R3,R4,R5);
    //calling release page
    functionNum = RELEASE_PAGE;
    R2 = block_num;
    call MEMORY_MANAGER;
    multipop(R1,R2,R3,R4,R5);
    
return;

release_block:
    multipush(R1,R2,R3,R4,R5);
    //calling release page
    functionNum = RELEASE_BLOCK;
    R2 = block_num;
    call MEMORY_MANAGER;
    multipop(R1,R2,R3,R4,R5);
return;